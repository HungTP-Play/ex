package ex

import (
	"testing"
	"time"
)

// Give n train stations.
// The train can only go forward.
// The cost of going from station i to station j is cost[i][j].
// Find the minimum cost of going from station 0 to station n-1.
//
// Example:
//
// 	Ex2(3, [][]int{
// 		[]int{0, 1, 3},
// 		[]int{1, 0, 1},
// 		[]int{2, 1, 0},
// 	})
//
// 	=> 2 (0 -> 1 -> 2)

// Subproblem: Find the minimum cost of going from station i to station j.
//
// Recurrence relation: Let's choose 3 stations (0->2), the minimum cost of going from
//
//	= Min {
//		 cost(0,2),
//		 cost(0,1) + cost(1,2),
//	}
//
// And with 4 stations (0->3), the minimum cost of going from
//
//	= Min {
//		 cost(0,3),
//		 cost(0,1) + cost(1,3),
//		 cost(0,2) + cost(2,3),
//	}
//
// And so on.
func TestEx2Recursive(t *testing.T) {
	tenCases := []struct {
		i    int
		j    int
		cost [][]int
		want int
	}{
		{
			0,
			2,
			[][]int{
				{0, 1, 3},
				{1, 0, 1},
				{2, 1, 0},
			},
			2,
		},
		{
			0,
			3,
			[][]int{
				{0, 1, 3, 4},
				{1, 0, 1, 2},
				{2, 1, 0, 1},
				{3, 2, 1, 0},
			},
			3,
		},
		{
			0,
			4,
			[][]int{
				{0, 1, 3, 4, 5},
				{1, 0, 1, 2, 3},
				{2, 1, 0, 1, 2},
				{3, 2, 1, 0, 1},
				{4, 3, 2, 1, 0},
			},
			4,
		},
		{
			0,
			5,
			[][]int{
				{0, 1, 3, 4, 5, 6},
				{1, 0, 1, 2, 3, 4},
				{2, 1, 0, 1, 2, 3},
				{3, 2, 1, 0, 1, 2},
				{4, 3, 2, 1, 0, 1},
				{5, 4, 3, 2, 1, 0},
			},
			5,
		},
		{
			0,
			6,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7},
				{1, 0, 1, 2, 3, 4, 5},
				{2, 1, 0, 1, 2, 3, 4},
				{3, 2, 1, 0, 1, 2, 3},
				{4, 3, 2, 1, 0, 1, 2},
				{5, 4, 3, 2, 1, 0, 1},
				{6, 5, 4, 3, 2, 1, 0},
			},
			6,
		},
		{
			0,
			7,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7, 8},
				{1, 0, 1, 2, 3, 4, 5, 6},
				{2, 1, 0, 1, 2, 3, 4, 5},
				{3, 2, 1, 0, 1, 2, 3, 4},
				{4, 3, 2, 1, 0, 1, 2, 3},
				{5, 4, 3, 2, 1, 0, 1, 2},
				{6, 5, 4, 3, 2, 1, 0, 1},
				{7, 6, 5, 4, 3, 2, 1, 0},
			},
			7,
		},
		{
			0,
			8,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7, 8, 9},
				{1, 0, 1, 2, 3, 4, 5, 6, 7},
				{2, 1, 0, 1, 2, 3, 4, 5, 6},
				{3, 2, 1, 0, 1, 2, 3, 4, 5},
				{4, 3, 2, 1, 0, 1, 2, 3, 4},
				{5, 4, 3, 2, 1, 0, 1, 2, 3},
				{6, 5, 4, 3, 2, 1, 0, 1, 2},
				{7, 6, 5, 4, 3, 2, 1, 0, 1},
				{8, 7, 6, 5, 4, 3, 2, 1, 0},
			},
			8,
		},
		{
			0,
			9,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7, 8, 9, 10},
				{1, 0, 1, 2, 3, 4, 5, 6, 7, 8},
				{2, 1, 0, 1, 2, 3, 4, 5, 6, 7},
				{3, 2, 1, 0, 1, 2, 3, 4, 5, 6},
				{4, 3, 2, 1, 0, 1, 2, 3, 4, 5},
				{5, 4, 3, 2, 1, 0, 1, 2, 3, 4},
				{6, 5, 4, 3, 2, 1, 0, 1, 2, 3},
				{7, 6, 5, 4, 3, 2, 1, 0, 1, 2},
				{8, 7, 6, 5, 4, 3, 2, 1, 0, 1},
				{9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
			},
			9,
		},
		{
			0,
			10,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11},
				{1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
				{2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8},
				{3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7},
				{4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6},
				{5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5},
				{6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4},
				{7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3},
				{8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2},
				{9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1},
				{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
			},
			10,
		},
	}

	var loopCount int = 0

	for _, tt := range tenCases {
		startTime := time.Now()
		got := Ex2_Recursive(tt.i, tt.j, tt.cost, &loopCount)
		endTime := time.Now()
		t.Logf("Ex2_Recursive(%d, %d) = %d, took %s\n", tt.i, tt.j, got, endTime.Sub(startTime))
		t.Logf("Ex2_Recursive(%d, %d) = %d, loopCount: %d\n", tt.i, tt.j, got, loopCount)
		if got != tt.want {
			t.Errorf("Ex2_Recursive(%d, %d) = %d, want %d", tt.i, tt.j, got, tt.want)
		}
		loopCount = 0
	}
}

func TestEx2Memoization(t *testing.T) {
	tenCases := []struct {
		i    int
		j    int
		cost [][]int
		want int
	}{
		{
			0,
			2,
			[][]int{
				{0, 1, 3},
				{1, 0, 1},
				{2, 1, 0},
			},
			2,
		},
		{
			0,
			3,
			[][]int{
				{0, 1, 3, 4},
				{1, 0, 1, 2},
				{2, 1, 0, 1},
				{3, 2, 1, 0},
			},
			3,
		},
		{
			0,
			4,
			[][]int{
				{0, 1, 3, 4, 5},
				{1, 0, 1, 2, 3},
				{2, 1, 0, 1, 2},
				{3, 2, 1, 0, 1},
				{4, 3, 2, 1, 0},
			},
			4,
		},
		{
			0,
			5,
			[][]int{
				{0, 1, 3, 4, 5, 6},
				{1, 0, 1, 2, 3, 4},
				{2, 1, 0, 1, 2, 3},
				{3, 2, 1, 0, 1, 2},
				{4, 3, 2, 1, 0, 1},
				{5, 4, 3, 2, 1, 0},
			},
			5,
		},
		{
			0,
			6,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7},
				{1, 0, 1, 2, 3, 4, 5},
				{2, 1, 0, 1, 2, 3, 4},
				{3, 2, 1, 0, 1, 2, 3},
				{4, 3, 2, 1, 0, 1, 2},
				{5, 4, 3, 2, 1, 0, 1},
				{6, 5, 4, 3, 2, 1, 0},
			},
			6,
		},
		{
			0,
			7,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7, 8},
				{1, 0, 1, 2, 3, 4, 5, 6},
				{2, 1, 0, 1, 2, 3, 4, 5},
				{3, 2, 1, 0, 1, 2, 3, 4},
				{4, 3, 2, 1, 0, 1, 2, 3},
				{5, 4, 3, 2, 1, 0, 1, 2},
				{6, 5, 4, 3, 2, 1, 0, 1},
				{7, 6, 5, 4, 3, 2, 1, 0},
			},
			7,
		},
		{
			0,
			8,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7, 8, 9},
				{1, 0, 1, 2, 3, 4, 5, 6, 7},
				{2, 1, 0, 1, 2, 3, 4, 5, 6},
				{3, 2, 1, 0, 1, 2, 3, 4, 5},
				{4, 3, 2, 1, 0, 1, 2, 3, 4},
				{5, 4, 3, 2, 1, 0, 1, 2, 3},
				{6, 5, 4, 3, 2, 1, 0, 1, 2},
				{7, 6, 5, 4, 3, 2, 1, 0, 1},
				{8, 7, 6, 5, 4, 3, 2, 1, 0},
			},
			8,
		},
		{
			0,
			9,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7, 8, 9, 10},
				{1, 0, 1, 2, 3, 4, 5, 6, 7, 8},
				{2, 1, 0, 1, 2, 3, 4, 5, 6, 7},
				{3, 2, 1, 0, 1, 2, 3, 4, 5, 6},
				{4, 3, 2, 1, 0, 1, 2, 3, 4, 5},
				{5, 4, 3, 2, 1, 0, 1, 2, 3, 4},
				{6, 5, 4, 3, 2, 1, 0, 1, 2, 3},
				{7, 6, 5, 4, 3, 2, 1, 0, 1, 2},
				{8, 7, 6, 5, 4, 3, 2, 1, 0, 1},
				{9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
			},
			9,
		},
		{
			0,
			10,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11},
				{1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
				{2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8},
				{3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7},
				{4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6},
				{5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5},
				{6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4},
				{7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3},
				{8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2},
				{9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1},
				{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
			},
			10,
		},
	}

	var loopCount int = 0

	for _, tt := range tenCases {
		startTime := time.Now()
		memLen := len(tt.cost)
		memo := make([][]int, memLen)
		for i := 0; i < memLen; i++ {
			memo[i] = make([]int, memLen)
		}
		got := Ex2_Memoization(tt.i, tt.j, tt.cost, &loopCount, memo)
		endTime := time.Now()
		t.Logf("Ex_Memoization(%d, %d) = %d, took %s\n", tt.i, tt.j, got, endTime.Sub(startTime))
		t.Logf("Ex_Memoization(%d, %d) = %d, loopCount: %d\n", tt.i, tt.j, got, loopCount)
		if got != tt.want {
			t.Errorf("Ex_Memoization(%d, %d) = %d, want %d", tt.i, tt.j, got, tt.want)
		}
		loopCount = 0
	}
}

func TestEx2DynamicProgramming(t *testing.T) {
	tenCases := []struct {
		i    int
		j    int
		cost [][]int
		want int
	}{
		{
			0,
			2,
			[][]int{
				{0, 1, 3},
				{1, 0, 1},
				{2, 1, 0},
			},
			2,
		},
		{
			0,
			3,
			[][]int{
				{0, 1, 3, 4},
				{1, 0, 1, 2},
				{2, 1, 0, 1},
				{3, 2, 1, 0},
			},
			3,
		},
		{
			0,
			4,
			[][]int{
				{0, 1, 3, 4, 5},
				{1, 0, 1, 2, 3},
				{2, 1, 0, 1, 2},
				{3, 2, 1, 0, 1},
				{4, 3, 2, 1, 0},
			},
			4,
		},
		{
			0,
			5,
			[][]int{
				{0, 1, 3, 4, 5, 6},
				{1, 0, 1, 2, 3, 4},
				{2, 1, 0, 1, 2, 3},
				{3, 2, 1, 0, 1, 2},
				{4, 3, 2, 1, 0, 1},
				{5, 4, 3, 2, 1, 0},
			},
			5,
		},
		{
			0,
			6,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7},
				{1, 0, 1, 2, 3, 4, 5},
				{2, 1, 0, 1, 2, 3, 4},
				{3, 2, 1, 0, 1, 2, 3},
				{4, 3, 2, 1, 0, 1, 2},
				{5, 4, 3, 2, 1, 0, 1},
				{6, 5, 4, 3, 2, 1, 0},
			},
			6,
		},
		{
			0,
			7,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7, 8},
				{1, 0, 1, 2, 3, 4, 5, 6},
				{2, 1, 0, 1, 2, 3, 4, 5},
				{3, 2, 1, 0, 1, 2, 3, 4},
				{4, 3, 2, 1, 0, 1, 2, 3},
				{5, 4, 3, 2, 1, 0, 1, 2},
				{6, 5, 4, 3, 2, 1, 0, 1},
				{7, 6, 5, 4, 3, 2, 1, 0},
			},
			7,
		},
		{
			0,
			8,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7, 8, 9},
				{1, 0, 1, 2, 3, 4, 5, 6, 7},
				{2, 1, 0, 1, 2, 3, 4, 5, 6},
				{3, 2, 1, 0, 1, 2, 3, 4, 5},
				{4, 3, 2, 1, 0, 1, 2, 3, 4},
				{5, 4, 3, 2, 1, 0, 1, 2, 3},
				{6, 5, 4, 3, 2, 1, 0, 1, 2},
				{7, 6, 5, 4, 3, 2, 1, 0, 1},
				{8, 7, 6, 5, 4, 3, 2, 1, 0},
			},
			8,
		},
		{
			0,
			9,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7, 8, 9, 10},
				{1, 0, 1, 2, 3, 4, 5, 6, 7, 8},
				{2, 1, 0, 1, 2, 3, 4, 5, 6, 7},
				{3, 2, 1, 0, 1, 2, 3, 4, 5, 6},
				{4, 3, 2, 1, 0, 1, 2, 3, 4, 5},
				{5, 4, 3, 2, 1, 0, 1, 2, 3, 4},
				{6, 5, 4, 3, 2, 1, 0, 1, 2, 3},
				{7, 6, 5, 4, 3, 2, 1, 0, 1, 2},
				{8, 7, 6, 5, 4, 3, 2, 1, 0, 1},
				{9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
			},
			9,
		},
		{
			0,
			10,
			[][]int{
				{0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11},
				{1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
				{2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8},
				{3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7},
				{4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6},
				{5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5},
				{6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4},
				{7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3},
				{8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2},
				{9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1},
				{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
			},
			10,
		},
	}

	var loopCount int = 0

	for _, tt := range tenCases {
		startTime := time.Now()
		memLen := len(tt.cost)
		memo := make([][]int, memLen)
		for i := 0; i < memLen; i++ {
			memo[i] = make([]int, memLen)
		}
		got := Ex2_DynamicProgramming(tt.i, tt.j, tt.cost, &loopCount, memo)
		endTime := time.Now()
		t.Logf("Ex_DynamicProgramming(%d, %d) = %d, took %s\n", tt.i, tt.j, got, endTime.Sub(startTime))
		t.Logf("Ex_DynamicProgramming(%d, %d) = %d, loopCount: %d\n", tt.i, tt.j, got, loopCount)
		if got != tt.want {
			t.Errorf("Ex_DynamicProgramming(%d, %d) = %d, want %d", tt.i, tt.j, got, tt.want)
		}
		loopCount = 0
	}
}
